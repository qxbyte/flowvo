

# ✅ 步骤流程（详细描述）
### 用户发送消息

前端发送用户输入的问题，例如：“请帮我查一下今天上海的天气”。

### 服务端封装消息（第一轮请求）

#### 构造 ChatCompletion 请求体：

包含用户消息。

附加当前支持的 functions 和 function descriptions。

明确提示：只回答是否需要调用 function call（是 或 否），不要包含其他解释内容。

### 大模型回复是否需要 function call

#### 模型返回：

"content": "是" 或 "content": "否"。

无需包含任何额外文本。

### 后端解析“是/否”响应

#### 如果是 "否"：

直接把用户问题再次发送给模型（不附加任何 function 信息），

获取回答，流式返回给前端。

#### 如果是 "是"：

###### 后端再次构造请求体：

包含用户原始消息。

附加所有 functions 的完整 JSON 格式。

明确提示模型只返回 function_call 字段中的调用信息（JSON）。

### 模型返回 Function Call JSON

#### 示例返回：

json
`{
  "function_call": {
    "name": "getWeather",
    "arguments": {
      "city": "上海"
    }
  }
}`
### 后端执行对应方法

后端使用反射（或统一注册的 handlerMap）找到对应方法。

执行调用，获取返回值。

### 返回 Function 结果

将函数返回值作为回答内容，流式发送到前端页面。

# 🔄 对话流逻辑图（文本图）

                        用户输入问题
                            ↓
            服务端封装问题 + function 描述发送给模型
                            ↓
                模型回复：是 / 否（不返回其他信息）
                            ↓
                    ┌────────────────┐
                  回复是？               
            ┌───────┘                └───────┐
            是                               否
            ↓                                ↓
    发送完整 functions JSON             直接再次发送问题给模型
    + 原始消息给模型                    （不包含function信息）
            ↓                                   ↓
    模型返回 function_call JSON          模型返回答案内容
            ↓                                   ↓
    后端解析并通过反射调用方法             将回答内容流式返回前端
            ↓
    函数执行结果作为回答流式返回前端
